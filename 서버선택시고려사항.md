# 서버선택시고려사항 및 트레픽 관리

## 관련 사이트
- https://velog.io/@wkdgus7113/%EC%84%9C%EB%B2%84%EA%B0%80-%EB%8C%80%EB%9F%89%EC%9D%98-%ED%8A%B8%EB%9E%98%ED%94%BD%EC%9D%84-%ED%95%B4%EA%B2%B0%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-Scale-Out-%EB%8B%A4%EC%A4%91%EC%84%9C%EB%B2%84-jk063hwk
- (스프링 대용량 트래픽 처리) https://www.nextree.io/seupeuring-daeyongryang-teuraepig-ceori/
- (서버 병목현상) https://fastercapital.com/ko/content/%EC%84%9C%EB%B2%84-%EB%B3%91%EB%AA%A9-%ED%98%84%EC%83%81-%ED%92%80%EA%B8%B0--%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81.html
- (100만 동시 접속 관련) https://velog.io/@tilsong/Mass-Ticket-100%EB%A7%8C-%EB%8F%99%EC%8B%9C-%EC%A0%91%EC%86%8D%EC%9D%84-%EA%B2%AC%EB%8E%8C%EB%82%B4%EB%8A%94-%ED%8B%B0%EC%BC%93-%EC%98%88%EB%A7%A4-%ED%86%A0%EC%9D%B4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8
- (네이버의 트래픽 처리) https://d2.naver.com/helloworld/6070967
- 

## 기본 배경
- 100KB 용량의 이미지를 10만명이 조회하면 대락 10GB의 트래픽이 발생(네이버페이지)하므로, 100번의 호출이면 10MB 정도.

### Thread 관리
- 스레드 개념 : 실행중인 한 프로그램(프로세스) 내에서 구분지어진 실행 단위
- CPU는 여러 스레드 단위로 스레드를 번갈아 가며 작업을 처리
- 스레드가 생성되면, 스레드는 필요한 메모리를 할당받아 처리하므로 스레드가 많아지면 스레드가 차지하는 메모리가 커져서 메모리가 부족해질 수 있다.
- 스레드가 많아지면 컨텍스트 스위칭(CPU에서 실행중이던 스레드가 다른 스레드로 바뀌는 것을 의미) 비용이 커진다. 컨텍스트 스위칭 비용이 컬지 것이므로 CPU의 시간을 소모하게 되고 더 나아가서는 CPU 에 오버헤닥 발생하여 성능이 저하 될 수 있습니다.

### Thread Pool?
- 스레드를 매번 생성한다면 매번 메모리를 사용하게 되므로 Thread Pool에 한번 생성한 스레드를 저장해놓는 방식으로 해당 문제를 보완할 수 있다.
- 스레드 풀은 '생성한 스레드를 보관하는 저장소'로서 이해하면됨. 스레드가 생성시 스레드 풀에 저장되고, 작업 처리 후 소멸되는 것이 아니라 스레드 풀에 남게되어 이후에 작업이 필요하면 해당 스레드를 재사용하여 작업을 처리
- 처리 과정
 1. 스레드 풀에 작업 처리 요청(Task Submitters)
 2. 작업요청이 작업 큐에 쌓인다(Task Queue)
 3. 작업 큐에 쌓인 작업들을 스레드 풀에 있는 스레드가 하나씩 맡아서 수행한다.(만약 처리할 스레드가 없다면 작업 큐에서 대기)
- 스레드 풀에서 '작업 큐'라는 큐를 도입하여 작업 처리 요청이 많아져도 작업 큐에서 대기하기 때문에 요청마낟 스레드의 개수를 늘리지 않고 슬데에ㅢ 전체 개수느는 일정하며 성능이 저하되지 않는다.

### Tomcat 설정(Tomcat Thread Pool)

- threads.min-spare : 톰캣 스레드 풀에 대기 상태로 있는 스레드 개수
- threads.max : 스레드 풀이 '동시에' 사용할 수 있는 최대 스레드 개수
- max-connections : Tomcat 서버가 '동시에 처리할 수 있는 최대 클라이언트 연결 수'
- accept-count : **max-connections 이상의 요청이 들어 왔을 때 사용하는 요청 대기열 큐의 사이즈** 만약 max-connections 이상의 연결 시도라서 요청 대기열 큐에 저장되는데, 요청 대기열 큐의 사이즈인 accept-count 보다도 연결 시도가 많아지면 연결을 거부한다.
- Java의 스레드 풀과 Tomcat의 스레드 풀의 차이는 '**accept-count**'와 관련이 있습니다.
- Java 스레드 풀의 Queue는 작업 큐로, 작업 요청이 들어오면 무조건 작업 큐를 거쳐서 스레드에 할당
- Tomcat에서 사용되는 Queue는 요청 대기열 큐로, 'max-connections 이상의 요청이 들어 왔을 때' 작업이 저장되게 됩니다.

```java
server:
  tomcat:
    accept-count: 5
    max-connections: 150
    threads:
      max: 50
      min-spare: 20

```
- min-spare: 20 - 기본적으로 스레드 풀에 대기 상태로 존재하는 스레드가 20개 있다.
- max: 50 - 스레드 풀이 동시에 사용할수 있는 초대 스레드 개수, 50개의 요청을 동시에 처리할 수 있다.
  만약 동시에 50개 요청이 오면, 대기 상태인 20개의 스레드를 제외하고 30개 스레드가 생성되어 50개의 요청을 동시 처리한다.
  TomcatConnector는 50개의 TCP Connection을 연결하고 있다.
- accept-count: 5 - 만약 100개의 요청이 오면, 최대 스레드 개수인 50개만큼 처리하고, 5개씩 큐에 저장
- max-connections: 150　－만약 200개의 요청이 오면, 150개의 요청이 수락되고 요청 대기여 큐 사이즈(accept-count)인 5만큼 요청이 수락되고, 나머지 45개의 요청은 거절된다.(이때, 요청 대기열 큐에 저장되는 작업들은 TCP Connection을 맺이 않고 있다.)

  




- 참고 : https://ksh-coding.tistory.com/116
